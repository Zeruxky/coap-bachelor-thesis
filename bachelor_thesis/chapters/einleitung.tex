\section{Einleitung}
\label{sec:einleitung}

Heutzutage haben Webdienste einen hohen Stellenwert im Internet. Sie sind häufig ein essenzieller Bestandteil von Anwendungen und werden durch eine \textit{Representation State Transfer} (REST)-Schnittstelle für Anwender und Entwickler angeboten. Auch das \textit{Internet of Things} (IoT) bekommt mit fortschreitender Zeit eine immer wichtigere Rolle in der Entwicklung von Anwendungen, wie zum Beispiel in der Hausautomatisierung oder smarte Energieverwaltung, wie in den wissenschaftlichen Berichten \citetitle{HomeAutomationUsingCoAP} von \citeauthor{HomeAutomationUsingCoAP} \autocite{HomeAutomationUsingCoAP}, \citetitle{okur2014study} von \citeauthor{okur2014study} \autocite{okur2014study}, \citetitle{TinyCoAP} von \citeauthor{TinyCoAP} \autocite{TinyCoAP} oder \citetitle{TransportLogisticUsingCoAP} von \citeauthor{TransportLogisticUsingCoAP} \autocite{TransportLogisticUsingCoAP} thematisiert wird.

Um die REST-Architektur auch für eingeschränkte Geräte anbieten zu können, wurde mit \textit{Constrained RESTful Environments} (CoRE) eine geeignete Form geschaffen. Somit können solche Geräte, wie zum Beispiel 8-Bit-Mikrocontroller mit begrenztem Arbeitsspeicher und Readonly-Memory (ROM), als auch Netzwerke, wie zum Beispiel \textit{IPv6 over Low-Power Wireless Area Networks (6LoWPANs)}, solche Architekturen verwenden und realisieren. Damit eine Fragmentierung von Nachrichten in solchen Netzwerken so gering wie möglich auftritt, wird im Constrained Application Protocol (CoAP) ein so niedriger Nachrichten-Overhead wie möglich angestrebt.

Mit CoAP wurde die Entwicklung eines generischen Webprotokolls für die speziellen Anforderungen dieser eingeschränkten Umgebungen, insbesondere mit Hauptaugenmerk auf Energie-, Gebäudeautomatisierungs- und andere Machine-to-Machine (M2M) Anwendungen vorangetrieben. Dabei sollte CoAP keine komprimierte Abwandlung von \textit{Hypertext Transfer Protocol}, abgekürzt HTTP, sein, sondern vielmehr eine Submenge von HTTP mit Verwendung von REST, die für M2M-Szenarien optimiert ist. Somit könnte CoAP leicht dazu verwendet werden, einfache HTTP-Schnittstellen in ein kompaktes Protokoll überzuführen, jedoch bietet CoAP Funktionen an, die speziell in Machine-to-Machine-Anwendungen Verwendung finden. Diese Funktionen sind:
\begin{itemize}
    \item Eingebaute Entdeckung von, im Netzwerk, angebotenen Services und Ressourcen.
    \item Mutlicast-Unterstützung.
    \item Asynchroner Nachrichtenaustausch.
\end{itemize}

In den, von CoAP angedachten Anwendungsgebieten, in denen eine große Menge an Daten über ein Netzwerk fließen, könnten asynchrone Techniken die passende Ergänzung sein, um eine hohe Anzahl von Nachrichten zu empfangen, zu versenden oder zu verarbeiten. Den mit steigender Digitalisierung in privaten als auch geschäftlichem Umfeld, im Form von intelligenter Haussteuerung, effizienter Nutzung von Energieerzeugern und Energieverbrauchern\footnote{\href{https://www.a1energysolutions.at/smartspeicher/}{SmartSpeicher} - intelligente Warmwasserspeicher zur Stabilisierung des Stromnetzes}, steigt auch der Bedarf an leistungsfähigen Anwendungen, die diese schnell anwachsende Anzahl an IoT-Geräten ressourcenschonend und effizient verwalten kann. 

Jedoch eignet sich Asynchronität nicht nur zur Optimierung von Anwendungen im IoT-Bereich, sondern auch für solche mit einer grafischen Programmoberfläche (GUI). Dies hat den Grund, da der für das Zeichnen der Oberfläche verantwortliche Thread freibleibt und somit neu ankommende Eingaben des Benutzers (Mausklick, Tastatureingabe etc.) verarbeiten werden kann, ohne das die Oberfläche "einfriert"\footnote{Beschreibung des Zustandes eines Programmes, indem die Oberfläche keine neuen Eingaben entgegennimmt}.

Dieses Programmierparadigma ist auch nützlich, wenn mit Datenbanken oder REST-Schnittstellen interagiert oder I/O- bzw. CPU-intensive Operationen ausgeführt werden, wie \citeauthor{okur2014study} in deren Studie \citetitle{okur2014study} \autocite{okur2014study} herausgefunden haben.

Das Ziel dieser Arbeit besteht nun darin einen Server, nach dem RFC 7252 von \citeauthor{RFC7252} \autocite{RFC7252}, der das \textit{Constrained Application Protocol} spezifiziert, zu implementieren. Dieser Server soll sowohl eine synchrone als auch asynchrone Schnittstelle zur Verarbeitung von Nachrichten anbieten, damit ein Vergleich der beiden Ausführungsparadigmen angestrebt werden kann. Hierbei spielt der \textit{Serializer}, welcher für das Lesen und Schreiben von CoAP-Nachrichten zuständig ist, eine große Rolle, da dieser einen wichtigen Platz im CoAP-Stack einnimmt. Der daraus resultierende Source Code wird öffentlich auf Github im Repository \href{https://github.com/world-direct/CoAP.NET}{world-direct/CoAP.NET} einsehbar sein und dort für weitere Entwicklungen zur Verfügung stehen.