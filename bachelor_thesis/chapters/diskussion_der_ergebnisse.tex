\section{Diskussion der Messergebnisse}
\label{sec:diskussion-der-messergebnisse}

Betrachtet man die dargelegten Messergebnisse in Kapitel \ref{sec:messung}, sieht man, dass bei großen und aufwendigen I/O-Operationen Asynchronität besser abschneidet. Im Gegensatz dazu schlagen sich synchrone Methoden besser, wenn sich Menge der Daten im reservierten Speicher, also kein Nachladen oder Anforderung von weiteren Daten, sofort verarbeiten lässt. Dies lässt sich damit argumentieren, dass, wenn sich alle Daten im Speicher befinden, die synchrone Methode / Programm die Daten ohne weiteren Aufwand verwenden kann. Hingegen bei asynchronen Methoden ist es unvorteilhaft, wenn die Daten sehr klein sind und sich somit der Mehraufwand zum Aufbau der dafür benötigten Zustandsmaschine nicht lohnt.

Wie man sieht, macht sich der Vorteil von Asynchronität nicht in jedem Szenario bezahlt, sondern kann sogar die Performanz einer Applikation drastisch senken. Darum gehen auch viele Entwickler von Softwareprogrammen, die gewisse asynchrone Methoden anbieten bzw. verwenden, dazu über, anhand von bestimmten Bedingungen oder Kriterien zu ermitteln, ob eine asynchrone oder eine synchrone Variante der zu implementierenden Funktion verwendet werden sollte. Damit sollte eine asynchrone Methode dem Entwickler zur Verfügung gestellt werden, die optimiert auf die jeweiligen Parameter ist.

Bedenkt man jedoch, dass der Vorteil der Asynchronität, zumindest im Zusammenhang mit dem Constrained Application Protocol, erst ab einer Payloadgröße von 1 GB zum Tragen kommen. Dies muss man als Entwickler abwägen, ob Nachrichten mit solch einer großen Payload innerhalb der Softwareapplikation zur Norm gehören. Dazu muss auch gesagt werden, dass einige Optimierungen sowohl in den synchronen und asynchronen Methoden vorgenommen werden können und somit Potenzial vorhanden ist. Diese sind auch Gegenstand von weiteren Maßnahmen, die man im Rahmen dieses Projekts vornehmen kann. Auf diese werden jedoch im Kapitel \ref{sec:schlussfolgerung} näher eingegangen.