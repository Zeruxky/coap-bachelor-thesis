\section{Schlussfolgerung}
\label{sec:schlussfolgerung}

Hat nun die asynchrone Implementation eines Servers, in diesem Falle des \textit{Serializer}s, einen Einfluss auf dessen Durchsatzrate? Diese Frage kann nicht eindeutig beantwortet werden. Diese ist abhängig davon, wie man folgende Fragen beantwortet:
\begin{itemize}
    \item Ist die Menge der zu verarbeitenden Daten klein? Wenn ja, dann hat Asynchronität keine große Auswirkung, sondern erzeugt eine erhebliche Mehrarbeit, aufgrund der zu erzeugenden Zustandsmaschine.
    \item Ist die Menge der zu verarbeitenden Daten groß? Wenn ja, dann hat Asynchronität eine große Auswirkung auf den Durchsatz, da durch die kürzere Verarbeitungszeit schneller neu ankommende Daten verarbeitet werden können.
\end{itemize}

Sieht man sich die Ergebnisse im Kapitel \ref{sec:messung} an, bemerkt man, dass diese nicht eindeutig für Asynchronität oder Synchronität sprechen. Wenn keine CoAP-Options enthalten sind, dann verringert sich der Abstand von den asynchronen zu den synchronen Methoden mit größer werdender Payload.

Ab dem Zeitpunkt, in dem CoAP-Optionen in die Nachricht eingefügt werden, ist die synchrone Variante in den meisten Situationen schneller als die asynchrone. Dadurch, dass die Menge an Bytes, die für eine einzelne Option benötigt wird, sehr gering ist, hat \textit{SerializeAsync} bzw. \textit{DeserializeAsync} immer den Mehraufwand für den Aufbau seiner asynchronen Zustandsmaschine.

Erst mit einer sehr großen Payload von 1 GB zeichnet sich ein deutliches Ergebnis pro Asynchronität ab - zumindest bei der Verwendung der \textit{SerializeAsync}-Methode. Hier ist \textit{SerializeAsync}, wie schon festgestellt worden ist, bei der durchschnittlichen Laufzeit um den Faktor 7 schneller und um den Faktor 143 effizienter im Speicherverbrauch als die \textit{Serialize}-Methode. 

Was bedeutet dies nun für die, in dieser Arbeit gestellten Ausgangsfrage? Eine eingebaute Asynchronität in Softwareprogrammen ist nicht für jedes Problem die passende Lösung. Es kann seine Vorteile gut in Situationen ausspielen, in denen auf ein Ergebnis einer zeit- oder rechenintensiven Aktion gewartet werden muss. Diese können in Form von Netzwerkübertragungen (Anfragen bzw. Antworten mittels HTTP, Datenbankabfragen), rechenintensiven Berechnungen oder speicherintensiven I/O-Vorgängen (Lesen einer großen Datei von der Festplatte) auftreten. Für einfache und schnell auszuführende Aufgaben ist eine asynchrone Methode eher die falsche Wahl, da wie schon erwähnt, der Aufwand der asynchronen Zustandsmaschine zu groß wird.

Darum ist es abhängig von den Anforderungen und Aufgabenstellung der zu entwickelnden Software. Interagiert der betreffende Codeteil mit externen Systemen (Datenbanksystemen, REST-APIs, Internetservern) oder führt dieser rechenintensive Berechnungen durch, dann ist das Verwenden von Asynchronität zu empfehlen, wie es schon \citeauthor{okur2014study} in deren Studie \citetitle{okur2014study} \autocite{okur2014study} klargestellt haben. Damit wird der Main-Thread entlastet, was dazu führt, dass bei Applikationen ohne grafisches Interface (GUI) die Auslastung des Threadpools reduziert wird und bei Applikationen mit GUI der Main-Thread nicht blockiert und somit die Oberfläche benutzbar bleibt.

Betrachtet man nun den Fall eines Servers, dann kann man dazu tendieren auf eine asynchrone Implementierung zu setzen, da hier Daten über ein beliebiges Medium, wie zum Beispiel Ethernet oder WLAN, und beliebiges Protokoll an den Server geschickt werden. Dabei weiß der Server jedoch nicht im Vorhinein, wann diese Übertragung komplett abgeschlossen ist. Um nicht den Main-Thread des Servers zu blockieren, wie es bei einem synchronen Server passieren würde, kann durch den Einsatz von Asynchronität der Main-Thread entlastet und somit der Durchsatz gesteigert werden. Vor allem im speziellen Fall, wenn eine große Menge an Daten (siehe Tabelle \ref{tab:benchmark-100000-1000000000}) verarbeitet werden muss, kann die Asynchronität eines Programms deutliche Performanz- und Speichervorteile bringen. Nur durch die Verwendung von Asynchronität können sieben CoAP-Nachrichten, mit einer großen Anzahl an Options (100000) und einer großen Payload (1 GB), in der gleichen Zeit verarbeitet werden, wie als wenn man die synchrone \textit{Serialize}-Methode verwendet.

Ist dies jedoch ein triftiger Grund, um nur asynchrone Programme zu schreiben? Nicht unbedingt. Es kommt auf die gestellten Anforderungen an die Software an, ob diese sehr performant und ressourcenschonend arbeiten sollte. Ist dies der Fall, dann sollte ein großes Augenmerk darauf gelegt werden, zu überlegen, an welchen Stellen im Programm eine asynchrone gegenüber einer synchronen Methode vorgezogen werden sollte. Hierbei bieten viele Bibliotheken, zumindest im C\#-Ökosystem, sowohl synchrone als auch asynchrone Methoden an, die genau dieselbe Funktion abbilden, jedoch abhängig davon, ob es synchron oder asynchron passieren soll. Ist man jedoch selbst ein Entwickler einer solchen Bibliothek, ist es schwierig abzuwägen, welche Methoden einer asynchronen oder einer synchronen Implementierung benötigen. Betrachtet man die Referenzquelle\footnote{\href{https://github.com/microsoft/referencesource}{Referenzquelle von Microsoft zu .NET}} von Microsoft für .NET an, sieht man, dass die Entwickler dazu tendieren, anhand von verschiedenen Parametern zu entscheiden, ob die darunterliegende Funktion synchron oder asynchron ausgeführt werden sollte. Ein fiktives Beispiel dafür wird im Listing \ref{listing:optimierte-asynchrone-methode} aufgeführt.

Für das CoAP-Protokoll, spezifiziert nach RFC 7252 von \citeauthor{RFC7252} \cite{RFC7252}, erzielt Asynchronität keine bemerkenswerten Verbesserungen, da durch die Größenlimitierung von UDP-Paketen, die mit einer maximalen Länge von 65 535 Bytes festgelegt ist, die Datenmenge zu klein ist. Implementiert man die Funktion des blockweisen Datentransfers, wie im RFC 7959 von \citeauthor{RFC7959}  \cite{RFC7959} beschrieben, könnte diese Limitierung umgangen werden und größere Datengrößen erzielt werden. Man kann sich auch dazu entscheiden auf die neuere Standardisierung, wie im RFC 8323  von \citeauthor{RFC8323} beschrieben \cite{RFC8323}, zu setzen, um größere Mengen an Daten, ohne großen Aufwand, zu übertragen.

Das Fazit aus dieser Arbeit ist damit, das der Vorteil von asynchronen Server bzw. Programmen sehr davon abhängt, in welchen Szenarien diese eingesetzt werden. Müssen viele Anfragen mit großer Datenmenge gleichzeitig verarbeitet werden, dann ist ein asynchroner Server einem synchronen vorzuziehen. Dies wird dadurch noch verstärkt, dass eine asynchrone Implementierung eines Servers, zumindest in C\#, durch eine einfache und durchdachte Syntax bestehend aus \mintinline{csharp}{async}, \mintinline{csharp}{await} und \mintinline{csharp}{Task} bzw. \mintinline{csharp}{Task<TResult>} ermöglicht wird. Auch ist der Trend bemerkbar, dass viele bekannte Bibliotheken eine große Anzahl an asynchronen Methoden anbieten, damit diese auch in asynchronen Konstrukten verwendet werden können.

Jedoch wird hier auch eine generelle Empfehlung zur Implementierung und Verwendung von asynchronen Methoden ausgesprochen. Die gemessenen, zeitlichen Unterschiede zwischen Asynchronität und Synchronität befinden sich im vertretbaren Rahmen. Ist man nicht auf vollkommene Optimierung der Performanz der Software fokussiert, ist dieser Unterschied vernachlässigbar.